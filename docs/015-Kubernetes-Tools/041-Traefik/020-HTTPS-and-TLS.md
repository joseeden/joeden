---
title: "HTTPS and TLS"
description: "HTTPS and TLS"
tags: 
- Cloud
- DevOps
- Containers
- Containerization
- Kubernetes
- Traefik
sidebar_position: 20
last_update:
  date: 2/5/2023
---

## Overview

To secure your app with HTTPS, Traefik lets you use different types of TLS certificates.

- Let Traefik auto-generate, if no cert is given (not trusted)
- Use your own (manual)
- Let’s Encrypt (automated and trusted)

This keeps your app safe with HTTPS, whether you set up the certificates yourself or let Traefik manage them.

- TLS settings can go in static or dynamic config
- If Let’s Encrypt is used, Traefik creates and renew certs for you

:::info 

Let’s Encrypt is usually the best choice if you want easy, secure, and automated certificate management. 

:::


## Self-Signed Certificates

If you don’t provide any certificate, Traefik will create a self-signed one.

- Automatically generated by Traefik
- Browser shows warning that it's not trusted

This is useful for testing, but not recommended for production.

## User-Defined Certificates

You can provide your own certificates if needed.

- Upload your cert and key files to Traefik
- Define their path in the configuration
- You can set more fine-grained configurations
- Traefik matches them to the correct entry points

You’re responsible for renewing these certificates before they expire.

**Sample Configuration (User-defined certificate):**

```yaml
tls:
  certificates:
    - certFile: "/certs/domain.crt"
      keyFile: "/certs/domain.key"
    - certFile: "/certs/another-domain.crt"
      keyFile: "/certs/another-domain.key"
```

Once mounted, Traefik will handle the rest automatically.


## Let’s Encrypt with Traefik

Let’s Encrypt lets Traefik create and renew certs for you automatically.

- No need to manually manage cert files
- Works well for testing and general use
- Certificates are renewed automatically before they expire

This is the easiest option when you don’t have strict company requirements.

## Types of Let’s Encrypt Challenges

Traefik supports different methods to prove domain ownership.

- **HTTP Challenge** 

  - A temporary URL is created for verification
  - Let’s Encrypt gives a token to Traefik
  - Token is then served back to Let’s Encrypt for verification

    ```bash
    http://<YOUR_DOMAIN>/.well-known/acme-challenge/<TOKEN>
    ```

- **DNS Challenge** 
  
  - A DNS TXT record is created using your DNS provider
  - Let’s Encrypt looks at the record to verify ownership
  - Works with wildcard certificates

- **TLS Challenge** 

  - Performs a handshake between Traefik and Let’s Encrypt
  - Uses port 443 and handles everything at the TLS level

Here’s how the HTTP Challenge works:

```ini
[certificatesResolvers.myresolver.acme]
  email = "admin@example.com"
  storage = "acme.json"
  [certificatesResolvers.myresolver.acme.httpChallenge]
    entryPoint = "web"
```

DNS challenges work similarly but require access to your DNS provider’s API.

## Matching Certificates to Entry Points

Traefik automatically links the certificate to the right port and domain.

- Port 443 is usually mapped to `websecure`
- Traefik uses the domain to choose the correct certificate

Once matched, your website will show the secure lock icon in the browser.

<div class="img-center"> 

![](/img/docs/all-things-devops-traefik-lets-encrypt-flow.png)

</div>



## Configuring TLS in Routers

You also need to tell Traefik when to use TLS in your router.

```yaml
labels:
  - "traefik.http.routers.myapp.tls=true"
  - "traefik.http.routers.myapp.entrypoints=websecure"
  - "traefik.http.routers.myapp.tls.certresolver=myresolver"
```

This enables TLS and tells Traefik to use Let’s Encrypt with your selected method.

## Static versus Dynamic Config

You can add your TLS settings to either config type.

- Static config requires a restart to update
- Dynamic config lets you reload without restarting

If you change certs often, use dynamic config for easier updates.


## Lab: Pre-requisites 

### Prepare your Domain 

Before using HTTPS with Traefik, make sure you have:

- A domain name for testing
- DNS records pointing to your DNS provider
- A DNS provider supported by TraefikA DNS provider supported by Traefik

heck the supported providers list here: [Traefik DNS Provider Integrations](https://docs.traefik.io/v2.3/https/acme/#providers)**

For example, my setup uses:

- Domain from Namecheap
- DNS hosted on DigitalOcean

After getting a domain, update its registrar settings so it points to your chosen DNS provider. If you're also using DigitalOcean, you can follow the steps here: [Adding a Domain in DigitalOcean](/docs/001-Personal-Notes/055-Homelab/040-DigitalOcean.md#adding-a-domain)

**NOTE:** Make sure your domain is fully set up and pointing to your server before proceeding with the labs. Propagation can take up to 24–48 hours, sometimes longer depending on the registrar and TLD.

To verify, you can run:

```bash
dig NS yourdomain.com
dig A yourdomain.com
```

If you are using DigitalOcean name servers, you should see:

```bash
;; ANSWER SECTION:
yourdomain.com.     1800    IN      NS      ns1.digitalocean.com.
yourdomain.com.     1800    IN      NS      ns2.digitalocean.com.
yourdomain.com.     1800    IN      NS      ns3.digitalocean.com.

;; ANSWER SECTION:
yourdomain.com.     300     IN      A       192.0.2.123
```

### Set Up DNS Records

Once you've changed your domain’s nameservers to your DNS provider, the next step is to add your DNS records there. 

Here are the DNS records I used. You can copy them but make sure to replace with your own domain details.

| Type | Hostname            | Value                   | TTL (seconds) |
| ---- | ------------------- | ----------------------- | ------------- |
| A    | `*.johnsmith.app`   | points to 34.201.50.100 | 30            |
| A    | `www.johnsmith.app` | points to 34.201.50.100 | 30            |
| A    | `johnsmith.app`     | points to 34.201.50.100 | 30            |

The IP `34.201.50.100` is my test machine's public IP. Point the DNS records to your machine's public IP.

You can also use shorthand names since they mean the same:

| Type | Hostname          | Value                   | TTL (seconds) |
| ---- | ----------------- | ----------------------- | ------------- |
| A    | `*.johnsmith.app` | points to 34.201.50.100 | 30            |
| A    | `www`             | points to 34.201.50.100 | 30            |
| A    | `@`               | points to 34.201.50.100 | 30            |

If you set this up in DigitalOcean, your DNS records should look like this:

| Type | Hostname            | Value                          | TTL (seconds) |
| ---- | ------------------- | ------------------------------ | ------------- |
| NS   | `johnsmith.app`     | points to ns1.digitalocean.com | 30            |
| NS   | `johnsmith.app`     | points to ns2.digitalocean.com | 30            |
| NS   | `johnsmith.app`     | points to ns3.digitalocean.com | 30            |
| A    | `*.johnsmith.app`   | points to 34.201.50.100        | 30            |
| A    | `www.johnsmith.app` | points to 34.201.50.100        | 30            |
| A    | `johnsmith.app`     | points to 34.201.50.100        | 30            |




<!-- ### If you're testing on your Windows Machine 

You might get a timeout error when deploying the stack in a later step. To fix this, temporarily allow incoming traffic on ports 80 and 443:

1. Open **Windows Defender Firewall with Advanced Security**:
   * Press `Win + R`, type `wf.msc`, press Enter.

2. In the left pane, click **Inbound Rules**.
3. In the right pane, click **New Rule...**.
4. Choose **Port**, click **Next**.
5. Select **TCP**, specify ports: `80,443`, click **Next**.
6. Choose **Allow the connection**, click **Next**.
7. Choose where to apply the rule (Domain, Private, Public). 
8. For testing, select all three, then click Next.
9. Name the rule `000-DELETE-LATER-Allow HTTP and HTTPS inbound`.
10. Click **Finish**. -->


### Clone the Repository 

To try out the examples, clone the project repository from GitHub. 

- Github repo: [joseeden/labs-traefik](https://github.com/joseeden/labs-traefik/tree/master)

Clone and move into the project directory:

```bash
git clone https://github.com/joseeden/labs-traefik.git 
cd labs-traefik/04-https-tls
```

Project structure:

```bash
04-https-tls
├── challenge-dns
│   ├── docker-compose.dns.yml
│   └── traefik.dns.yml
├── challenge-http
│   ├── docker-compose.http.yml
│   └── traefik.http.yml
├── challenge-tls
│   ├── docker-compose.tls.yml
│   └── traefik.tls.yml
├── letsencrypt
```

**Note:** Make sure the `letsencrypt` folder is next to the `challenge` folders, not inside any of them. The Docker compose files expect it there. If you move the `letsencrypt` folder, remember to update the Docker compose files accordingly.


## Lab: Enable HTTPS Using Let's Encrypt (HTTP Challenge)

In this lab, we’ll use **Let’s Encrypt with the HTTP challenge** to automatically get TLS certificates for your app.

- Let’s Encrypt will verify your domain using an HTTP request
- Traefik will handle all the communication and certificate setup
- You just need to update a few values in the config files


#### Setup a Public Cloud VM 

It is recommended to perform this lab on a a VM with a public IP because you need to open port 80 to the internet.

- Your DNS records must point to the VM’s public IP.
- Let’s Encrypt can verify your site via HTTP without problems.

If you do this lab in your local Windows machine, it is likely that your machine has a private LAN IP like `192.168.x.x` behind NAT. 

You can definitely tweak your Windows machine’s firewall to allow inbound connections on port 80 (and 443), but this alone won’t fix the main problem if your router or network blocks/doesn’t forward that traffic.

To create a public cloud VM, you can use:

- [Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html)
- [Azure virtual machine](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/quick-create-portal) 
- [GCP Compute Engine](https://cloud.google.com/products/compute)
- [DigitalOcean droplet](https://docs.digitalocean.com/products/droplets/how-to/create/) 
- [Linode instance](https://www.linode.com/docs/guides/create-a-linode/)

#### Prepare the Files 

Inside the lab directory, we'll use' `traefik.http.yaml` to enable Let's Encrypt with HTTP challenge. This config tells Traefik to request and manage certificates using HTTP.

```yaml
api:
  dashboard: true
  insecure: true

providers:
  docker:
    exposedByDefault: false
log:
  level: INFO

entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"

# Challenge HTTP
certificatesResolvers:
  myresolver:             ## Will be used for label
    acme:
      email: your_email@example.com 
      storage: acme.json
      httpChallenge:
        entryPoint: web
```

:::info 

Make sure to replace the email address with your real email
 
:::


In the `docker-compose.http.yaml`, we'll set up our app with HTTPS using Traefik labels.

```yaml
version: "3"

services:
  traefik:
    image: traefik:v2.3
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ../letsencrypt:/letsencrypt
      - ./traefik.http.yml:/etc/traefik/traefik.yml

  catapp:
    image: mikesir87/cats:1.0
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.catapp.rule=Host(`yourdomain.com`)"
      - "traefik.http.routers.catapp.service=catapp"
      - "traefik.http.services.catapp.loadbalancer.server.port=5000"
      - "traefik.http.routers.catapp.entrypoints=websecure"
      - "traefik.http.routers.catapp.tls.certresolver=myresolver"
```

:::info 

Change `yourdomain.com` to your actual domain

::::

With these labels, Traefik will route HTTPS traffic and get certificates automatically.


#### Deploy and Test

To deploy the stack:

```bash
docker stack deploy -c ./challenge-http/docker-compose.http.yml traefik
```

Output:

```bash
Creating network traefik_default 
Creating service traefik_traefik
Creating service traefik_catapp
```

Then check the logs to verify the certificate process:

```bash
docker service logs traefik_traefik
```

Look for lines like:

```
level=info msg="Configuration loaded from file: /etc/traefik/traefik.yml"
level=info msg="Traefik version 2.3.7 built on 2021-01-11T18:03:02Z"
.....
level=info msg="Testing certificate renew..." providerName=myresolver.acme
```

If successful, visit your domain using HTTPS. You should see the secure padlock icon in the browser. 

<!-- insert-photo -->

Click the lock icon to see more details about the certificate. It will show **Let’s Encrypt** as the issuer.

<!-- insert-photo -->


#### Confirm in Traefik Dashboard

Open the dashboard (usually at port 8080), go to **Routers**, and click the `catapp@docker` application.

- TLS is marked as **enabled**
- The router uses `websecure` as the entry point
- The certificate resolver is set to `myresolver`

Go to **Services** and click `catapp@docker`. In the **Used by Routers** section, it will also show TLS is enabled for the application.

<!-- insert-photo -->


#### Cleanup

Before proceeding to the next lab, make sure to delete the deployed stack first:

```bash
docker stack rm traefik 
```


## Lab: Enable HTTPS Using Let's Encrypt (TLS Challenge)

This time, we'll use **Let's Encrypt with the TLS challenge**, which happens during the TLS handshake, not over HTTP.

- No need to expose port 80 (only 443 is used)
- Everything works over secure HTTPS
- Traefik handles all the challenge logic behind the scenes

The setup is nearly the same as the HTTP challenge, but simpler in some ways since it uses only one port.


#### Update Traefik Static Config (TLS Challenge)

Just like before, we configure a certificate resolver. The only real change is switching from `httpChallenge` to `tlsChallenge`. 

```yaml
# traefik.tls.yaml
api:
  dashboard: true
  insecure: true

providers:
  docker:
    exposedByDefault: false

log:
  level: INFO

entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"

# Challenge TLS
certificatesResolvers:
  myresolver:
    acme:
      email: your_email@example.com 
      storage: acme.json
      tlsChallenge: true        # Use TLS-ALPN challenge over port 443
        # # used during the challenge
        # entryPoint: web
```

:::info 

Replace with your own email for `email:` so Let’s Encrypt can contact you

:::


With this config, Traefik will request certificates without needing to serve any HTTP content.


#### Add TLS Labels in Compose

Now apply the right labels to your app in the `docker-compose.tls.yml`

```yaml
version: "3"

services:
  traefik:
    image: traefik:v2.3
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ../letsencrypt:/letsencrypt # Copy Let's Encrypt certificate locally for backing up
      - ./traefik.tls.yml:/etc/traefik/traefik.yml

  catapp:
    image: mikesir87/cats:1.0
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.catapp.rule=Host(`your_domain_here`)"
      - "traefik.http.routers.catapp.service=catapp"
      - "traefik.http.services.catapp.loadbalancer.server.port=5000"
      - "traefik.http.routers.catapp.entrypoints=websecure"
      - "traefik.http.routers.catapp.tls.certresolver=myresolver"
```

:::info 

Replace `yourdomain.com` with your real domain

:::

These labels tell Traefik how to route HTTPS requests and which resolver to use for TLS.


#### Deploy the Stack

Now deploy the new setup with TLS challenge:

```bash
docker stack deploy -c docker-compose.tls.yaml traefik
```

Check the logs to watch the challenge in action:

```bash
docker service logs traefik_traefik
```

You should see lines like:

```
Testing certificate renew...
Using TLS-ALPN challenge
Certificate obtained successfully
```

That means Let’s Encrypt verified your domain using TLS and issued the certificate.


#### Test in Browser and Dashboard

Visit your domain using the correct HTTPS URL:

```bash 
https://yourdomain.com
```

<!-- insert-photo-here -->

Check the Traefik dashboard at:

```bash
https://yourdomain.com:8080
```

Then go to **HTTP Services**, select the `catapp` service, and confirm that TLS is marked as **enabled**.


<!-- insert-photo-here -->



#### Cleanup

Before proceeding to the next lab, make sure to delete the deployed stack first:

```bash
docker stack rm traefik 
```


## Lab: Enable HTTPS Using Let's Encrypt (DNS Challenge)

In this lab, we’ll set up **Traefik with Let’s Encrypt DNS challenge**, which allows automatic creation of wildcard certificates, meaning you can secure all subdomains (like `app.yourdomain.com`, `api.yourdomain.com`) with a single certificate.

- Wildcard certs cover many subdomains
- DNS challenge updates DNS records automatically
- Works without exposing HTTP port (uses DNS + HTTPS only)

This method is fully automated and gives you more flexibility with subdomains.


#### Prepare Your DNS Provider

Before starting, you need a wildcard DNS record pointing to your server.

1. Add a `*.yourdomain.com` record pointing to your server’s IP
2. Add an `@` (root) record pointing to the same IP

This allows Traefik to request certificates for any subdomain you choose later; no need to manually add DNS entries every time.

|Type | Hostname | Value | TTL(seconds) | 
|-----|--------|--------|--------------|
| A   | *.your-domain.com | directs to  (add ip) | 30 |
| A   | www.your-domain.com | directs to  (add ip) | 30 |
| A   | your-domain.com | directs to  (add ip) | 30 |

#### Create an API Token (DigitalOcean)

To allow Traefik to update DNS records automatically, you’ll need a token from your DNS provider.

1. Go to your DNS provider’s dashboard (e.g., DigitalOcean)
2. Generate a new API token with DNS access
3. Copy the token. This will be added to the Docker compose

This token is used by Traefik to prove domain ownership via the DNS challenge.


#### Add API Token in Docker Compose

Now configure the Docker Compose file with the DNS token and labels.

Inside the repo, we have the `docker-compose.dns.yml`

```yaml
# docker-compose.dns.yaml
version: "3"

services:
  traefik:
    image: traefik:v2.3
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ../letsencrypt:/letsencrypt                  
      - ./traefik.dns.yml:/etc/traefik/traefik.yml  
    environment:
      - "DO_AUTH_TOKEN=<your_api_token_here>"

  catapp:
    image: mikesir87/cats:1.0
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.catapp.rule=Host(`anything.your_domain_here.com`)"
      - "traefik.http.routers.catapp.service=catapp"
      - "traefik.http.services.catapp.loadbalancer.server.port=5000"
      - "traefik.http.routers.catapp.entrypoints=websecure"
      - "traefik.http.routers.catapp.tls.certresolver=myresolver"
```

Note: 

- Replace `your_api_token_here` with the token you generated
- Change the domain in `Host(...)` to match your wildcard domain
- Make sure to mount a local volume for `/letsencrypt` to store certs

As a recap, the DNS records that we have are:

| Type | Hostname            | Value                | TTL(seconds) |
| ---- | ------------------- | -------------------- | ------------ |
| A    | *.your-domain.com   | directs to  (add ip) | 30           |
| A    | www.your-domain.com | directs to  (add ip) | 30           |
| A    | your-domain.com     | directs to  (add ip) | 30           |

In the Docker compose file, we have set the rule to match for `anything.your_domain_here.com`, which technically matches `*.your-domain.com `. What this means is that Traefik will automatically request a wildcard certificate for `*.your-domain.com` using the DNS challenge, which...

By setting these labels and environment variables, Traefik will be able to generate certificates automatically.



#### Set Up Static Traefik Config (DNS Challenge)

The `traefik.dns.yml` sets the static config for the DNS challenge and the right provider.


```yaml
# traefik.dns.yaml
api:
  dashboard: true
  insecure: true

providers:
  docker:
    exposedByDefault: false

log:
  level: INFO

entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"

# Challenge DNS
certificatesResolvers:
  myresolver:
    acme:
      email: your_email@example.com 
      storage: /letsencrypt/acme.json
      dnsChallenge:
        provider: digitalocean
        delayBeforeCheck: 0
```

**Note:** 

- Replace `email:` with your real address
- Set `provider:` to match your DNS provider name (e.g., `digitalocean`)
- The `myresolver` name must match the Docker Compose labels later

This config tells Traefik to request certificates using DNS, with your provider’s API.



#### Deploy the Stack

Make sure no other stack is running before deployment:

```bash
docker stack rm traefik
```

Now deploy your updated setup:

```bash
docker stack deploy -c docker-compose.dns.yaml traefik
```

Check the logs to verify that the certificate was issued:

```bash
docker service logs traefik_traefik
```

You should see messages about the DNS challenge and a successful certificate request.


#### Test in Browser

Open your browser and visit:

```
https://training.yourdomain.com
```

You should see the app running with a valid HTTPS certificate. No DNS config was needed manually.

To test further, update the Compose file to use a new subdomain:

```yaml
- "traefik.http.routers.catapp.rule=Host(`dnslab.yourdomain.com`)"
```

Re-deploy the stack and Traefik will request a new certificate using the same wildcard.

Now visit:

```
https://dnslab.yourdomain.com
```

It should load securely, using the wildcard certificate.


#### Store Certificates Safely

To avoid rate limits and protect your certs:

- Always mount the `/letsencrypt` directory outside the container
- Backup your `acme.json` file which stores certs
- Avoid deleting containers without saving this file

```bash
# Store and check certificate file
ls ./letsencrypt/acme.json
```

If the cert file is lost and you request too many new ones, Let’s Encrypt may block further requests temporarily.


#### Use Secrets for Tokens (Best Practice)

Instead of writing your DNS API token directly in the file:

- Use Docker secrets to keep it hidden
- Avoid exposing sensitive tokens in version control

This helps keep your system secure while still allowing full automation.

