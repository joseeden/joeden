---
title: "OOP"
description: "Object Oriented Programming"
tags: 
- Computer Science
- Application Development
- Software Development
- Web Development
- Ruby
sidebar_position: 15
last_update:
  date: 8/24/2023
---


## Overview

Object Oriented Programming (OOP) is about using objects to organize and manage data in your programs. 

- **Objects** represent individual things in your program
- **Classes** are blueprints for creating objects
- **Attributes** store information about an object

In the example below, the class (Car) contains attributes that represent the color, brand, and model of a Car object. From this class, we can instantiate two objects that can inherit the attributes and methods of the parent class (Car).

<div class='img-center'>

![](/img/docs/Screenshot-2025-12-21-155944.png)

</div>

## Objects and Classes

Everything in Ruby is an object. Objects combine **state** (data) and **behavior** (methods) that define what the object can do.

- Objects store their own data using **instance variables**
- The **class** defines the blueprint for objects
- Classes also define **methods**, which are actions objects can perform

Example: A `Student` class can have attributes like:

- `first_name`
- `last_name`
- `email`
- `username`

Each student object stores its own values but follows the same blueprint.

```ruby
class Student
  # class blueprint goes here
end
```


## Attributes

Attributes are stored in **instance variables**, which start with `@`. These hold data for each object created from the class.

```ruby
class Student
  @first_name 
  @last_name 
  @email 
end
```

At this point, the object has placeholders but no actual values yet, which is why instance variables must be set before use.


## Custom Output With `to_s`

Ruby prints objects using the `to_s` method by default. You can override it to control what gets displayed.

```ruby
## student.rb 

class Student
  @first_name 
  @last_name 
  @email 

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end
end
```

To run the script:

```ruby
ruby student.rb 
```

If no values are set, printing the object will show empty fields.


## Setting Attributes With Methods

We can define methods to set attribute values from outside the class.

```ruby
class Student
  @first_name 
  @last_name 
  @email 

  def first_name(name)
    @first_name = name
  end

  def to_s
    "Full name: #{@first_name}"
  end
end

## Creates an object 
student1 = Student.new

## Sets the value
student1.first_name("Jordan")
puts student1
```

Output:

```ruby
Full name: Jordan
```

This shows how methods allow objects to receive data safely.

## Setter Methods

Setter methods are a Ruby convention that use `=` in the method name.

```ruby
class Student
  @first_name 
  @last_name 
  @email 

  def first_name=(name)
    @first_name = name
  end

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end
end

# Create object
student1 = Student.new

# Set value
student1.first_name = "James"
puts student1
```

Output:

```ruby
Full name: James 
```

## Getter Methods

To retrieve attribute values, we can define **getter methods**. These methods return the value of instance variables.

```ruby
class Student
  @first_name 
  @last_name 
  @email 

  def first_name=(name)
    @first_name = name
  end

  def first_name
    @first_name
  end

  def to_s
    "Full name: #{@first_name}"
  end
end

# Create object
student1 = Student.new

# Set value to first name
student1.first_name = "James"

## Retrieve just the first name value
puts student1.first_name
``` 

Output:

```ruby
James
```

Even though both methods use the same name, the format decides their role.

```ruby
## Setter 
def first_name=(name)
  @first_name = name
end

## Getter
def first_name
  @first_name
end 
```

## Repetition With Getters and Setters

Defining getters and setters for every attribute quickly adds a lot of repeated code. Consider the example below:

```ruby
class Student
  @first_name 
  @last_name 
  @email 

  def first_name=(name)
    @first_name = name
  end

  def first_name
    @first_name
  end

  def last_name=(name)
    @last_name = name
  end

  def last_name
    @last_name
  end

  def email=(email)
    @email = email
  end

  def email
    @email
  end

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end
end

# Create object
student1 = Student.new

# Sets value for full name
student1.first_name = "James"
student1.last_name = "Dean"
student1.email = "james.dean@abc.com"

## Retrieve just the first name value
puts student1
```


This works, but Ruby provides a simpler way to handle this pattern using **attribute accessors.**

## Attribute Accessor

Ruby can automatically create getters and setters using built-in helpers.

- `attr_accessor` - Creates getters and setters
- `attr_reader` - Creates getters only
- `attr_writer` - Creates setters only

Using accessors removes repetition and keeps the class clean.

```ruby
class Student
  attr_accessor :first_name, :last_name, :email 

  @first_name 
  @last_name 
  @email 

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end
end

# Create object
student1 = Student.new

# Sets values
student1.first_name = "James"
student1.last_name = "Dean"
student1.email = "james.dean@abc.com"

## Retrieve values
puts student1
puts student1.email
```

Output:

```ruby
Full name: James Dean
james.dean@abc.com
```

## Read Only Attributes

If you only want an attribute to be readable and not changeable, you can use `attr_reader`.

- It allows read access only
- Prevents the value from being changed outside the class
- Requires the value to be set from within the class

When `attr_reader` is used, Ruby creates a getter but no setter. This means the attribute can be accessed but not modified from outside the class.

```ruby
class Student
  attr_accessor :first_name, :last_name
  attr_reader :email 

  @first_name 
  @last_name 
  @email 

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end

  def email 
    @email = "james.dean@abc.com"
  end
end

# Create object
student1 = Student.new

# Sets value for full name
student1.first_name = "James"
student1.last_name = "Dean"

## Retrieve just the first name value
puts student1
puts student1.email 
```

Output:

```ruby
Full name: James Dean
james.dean@abc.com
```

As we can see, this still involves a fair amount of code just to set up a single object. Ruby simplifies this further by using a constructor method called `initialize`.


## Constructor with `initialize`

The `initialize` method runs automatically when a new object is created. It allows attributes to be set at the moment the object is instantiated.

```ruby
class Student
  attr_accessor :first_name, :last_name, :email 

  def initialize(first_name, last_name, email)
    @first_name = first_name
    @last_name = last_name
    @email = email
  end

  def to_s
    "Full name: #{@first_name} #{@last_name}"
  end
end

student1 = Student.new("Alex", "Smith", "alex.smith@abc.com")
student2 = Student.new("Maria", "Lopez", "maria.lopez@abc.com")
student3 = Student.new("Ted", "Mosby", "ted.mosby@abc.com")
student4 = Student.new("James", "Dean", "james.dean@abc.com")

puts student1
puts student2
puts student3
puts student4
```

With this approach, the code becomes shorter and easier to read, and creating multiple objects is much more straightforward.

When run, it outputs:

```ruby
Full name: Alex Smith
Full name: Maria Lopez
Full name: Ted Mosby
Full name: James Dean 
```

Each object holds its own values, but they all follow the same class structure.


## Creating Objects

This has already been shown in earlier examples, but to create an object in Ruby, you use the `new` method on a class.

```ruby
class Student
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

end

student1 = Student.new("Alex", "Smith")
student2 = Student.new("Maria", "Lopez")

puts student1
puts student2
```

Printing an object directly shows Rubyâ€™s default representation. This is the default behavior of the to_s method when it has not been customized.

Output:

```ruby
#<Student:0x00007d3d2c527948>
#<Student:0x00007d3d2c527678>
```



## Methods

Methods are functions defined inside a class that objects can call. Previous examples showed *getter* and *setter* methods; here is another simple example.

```ruby
class Student
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def full_name
    "Full name: #{@first_name} #{@last_name}"
  end
end

student = Student.new("Alex", "Smith")
puts student.full_name
```

Output:

```ruby
Full name: Alex Smith
```

This allows you to control what each object shows when printed.
