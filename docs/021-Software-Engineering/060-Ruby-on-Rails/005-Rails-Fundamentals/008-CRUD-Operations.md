---
title: "CRUD Operations"
description: "CRUD Operations"
tags: 
- Computer Science
- Application Development
- Software Development
- Web Development
- Ruby
- Ruby on Rails
sidebar_position: 8
last_update:
  date: 8/24/2023
---


## Overview

:::info 

This page builds on the concepts discussed in the [Backend](/docs/021-Software-Engineering/060-Ruby-on-Rails/005-Rails-Fundamentals/004-Backend.md#generate-a-resource-with-scaffold) page.

To follow this section, create a [simple Rails application.](/docs/021-Software-Engineering/060-Ruby-on-Rails/005-Rails-Fundamentals/003-Create-the-Rails-App.md). 

The complete config files can be found here: [Github/test-rails-app](https://github.com/joseeden/test-rails-app/tree/3a17f32ed06ba18908e71891f80bd6d02fe6b974)

:::

In the previous page, the application was created and the `article` has been generated using scaffold. This time, we want to create the resource manually without using scaffold.

Note that `article` follows a fixed structure that connects different layers of the app:

- Table: `articles`
- Model: `article` (singular, CamelCase)
  - Model file name: `article.rb`
  - Model class name: `Article` 

The `article` model (singular, CamelCase) is automatically mapped to an `articles` table (plural).

## (Optional) Cleanup Scaffolded Resources

If you generated the `articles` table, you can remove everything that scaffold created:

1. Roll back the scaffold migration (Recommended)

    If you haven’t committed yet, this is the safest way.

    ```bash
    rails db:rollback
    ```

    If there were multiple migrations run:

    ```bash
    rails db:rollback STEP=1
    ```

    This will:

    - Drop the `articles` table
    - Revert the database schema

2. Remove these files/directories if they exist:

    - `app/models/article.rb`
    - `app/controllers/articles_controller.rb`
    - `app/views/articles/`
    - `app/helpers/articles_helper.rb`
    - `app/assets/stylesheets/articles.scss` (or `.css`)
    - `test/models/article_test.rb` or `spec/models/article_spec.rb`
    - `test/controllers/articles_controller_test.rb` or specs

3. Edit `config/routes.rb` and delete:

    ```ruby
    resources :articles
    ```

4. If you want it fully gone:

    ```bash
    rm db/migrate/*create_articles*.rb
    ```

    Then reset the database if needed:

    ```bash
    rails db:reset
    ```

    ⚠️ **Warning**: `db:reset` drops and recreates the database — only do this in dev.


## `articles` Table Structure

Before creating the table, we define what it needs to store.

- `id` 
  - Serves as the primary key
  - Auto-generated by Rails 
  - Uniquely identifies each article 

- `title` 
  - Uses the `string` type
  - Limited in length (255 characters)

- `description` 
  - Uses the `text` type 
  - Supports longer content

Here's a sample table: 

| id  | title       | description            | user_id |
| --- | ----------- | ---------------------- | ------- |
| 1   | First post  | Introduction article   | 101     |
| 2   | Second post | Follow-up content      | 101     |
| 3   | Third post  | Another sample article | 203     |
| 4   | Fourth post | Deeper topic overview  | 145     |
| 5   | Fifth post  | Final example entry    | 203     |


## Creating the Table 

Tables are created through migration files. Migrations describe database changes and are applied in order. In the example below, a migration is generated to create the `articles` table.

```bash
rails generate migration create_articles
```

Rails creates a new migration file called `db/migrate/20230111005920_create_articles.rb`. The timestamp in the filename ensures migrations run in the correct order.

```ruby
class CreateArticles < ActiveRecord::Migration[6.1]
  def change
    create_table :articles do |t|
      t.timestamps
    end
  end
end
```

**Note:** When you use the `create_` prefix in the migration name, Rails assumes you are creating a table and auto-generates a `create_table` block, which includes the `t.timestamps`.

Modify the `articles` table and add a `title` column with a string type:

```ruby
class CreateArticles < ActiveRecord::Migration[6.1]
  def change
    create_table :articles do |t|
      t.timestamps
      t.string :title
    end
  end
end
```

Apply the migration to create the table.

```bash
rails db:migrate
```

Rails runs any migrations that have not been applied yet. After this completes, the `articles` table exists in the database. You can confirm this in `db/schema.rb`.

**Note:** I have another `application_records` in my schema because I have a another migration file in my `db` folder.

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_005920) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "articles", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.string "title"
  end
end
```

Once a migration has been run, Rails will not run it again because Rails tracks executed migrations. 

- Re-running `rails db:migrate` skips completed files
- Changes to old migrations are ignored

Editing a previously run migration will not update the database schema. This behavior prevents unexpected changes across environments. To update the table, you would need to do a rollback.


## Rolling Back a Migration (for Local Testing)

The most recent migration can be undone using a rollback.

```bash
rails db:rollback
```

Output:

```bash
== 20230111005920 CreateArticles: reverting ===================================
-- drop_table(:articles)
   -> 0.0085s
== 20230111005920 CreateArticles: reverted (0.0210s) ==========================
```

This reverts the last migration and removes the `articles` table. If you check` db/schema`.rb, you’ll see that the `articles` table is no longer present.

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_005920) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
```

At this stage, you can modify the migration to add the required fields and run `rails db:migrate` again to recreate the table. This is fine for local testing, but it’s not recommended for shared projects. 

In those cases, the better approach is to create a new migration instead.


## Adding New Changes using a New Migration

The correct way to update the database is to create a new migration.

First, generate a new migration.

```bash
rails generate migration add_desc_to_articles
```

This creates the `db/migrate/20230111012349_add_desc_to_articles.rb`. Since the migration name we used is generic, Rails didn't know what to add in the file.

```ruby
## db/migrate/20230111012349_add_desc_to_articles.rb
class AddDescToArticles < ActiveRecord::Migration[6.1]
  def change
  end
end
```

Update the migration file to add the `description` columns.

```ruby
## db/migrate/20230111012349_add_desc_to_articles.rb
class AddDescToArticles < ActiveRecord::Migration[6.1]
  def change
    add_column :articles, 
               :description,
               :text 
  end
end
```

Run the migration to apply the changes.

```bash
rails db:migrate
```

**Note:** Because we rolled back the migration earlier, the `articles` table had not been created yet. Running the migrate again now creates the table with both the `title` and `description` columns.

Checking the `db/schema.rb` again:

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_014617) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "articles", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.text "description"
    t.string "title"
  end
end
```



## Next step

The articles table is now fully defined and follows Rails conventions. With the database ready, the next step is to work with the Article model and connect it to the rest of the application.
