---
title: "CRUD Operations"
description: "CRUD Operations"
tags: 
- Computer Science
- Application Development
- Software Development
- Web Development
- Ruby
- Ruby on Rails
sidebar_position: 8
last_update:
  date: 8/24/2023
---


## Overview

:::info 

This page builds on the concepts discussed in the [Backend](/docs/021-Software-Engineering/060-Ruby-on-Rails/005-Rails-Fundamentals/004-Backend.md#generate-a-resource-with-scaffold) page.

To follow this section, create a [simple Rails application.](/docs/021-Software-Engineering/060-Ruby-on-Rails/005-Rails-Fundamentals/003-Create-the-Rails-App.md). 

The complete config files can be found here: [Github/test-rails-app](https://github.com/joseeden/test-rails-app/tree/3a17f32ed06ba18908e71891f80bd6d02fe6b974)

:::

In the previous page, the application was created and the `article` has been generated using scaffold. This time, we want to create the resource manually without using scaffold.

Note that `article` follows a fixed structure that connects different layers of the app:

- Table: `articles`
- Model: `article` (singular, CamelCase)
  - Model file name: `article.rb`
  - Model class name: `Article` 

The `article` model (singular, CamelCase) is automatically mapped to an `articles` table (plural).

## (Optional) Cleanup Scaffolded Resources

If you generated the `articles` table, you can remove everything that scaffold created:

1. Roll back the scaffold migration (Recommended)

    If you haven’t committed yet, this is the safest way.

    ```bash
    rails db:rollback
    ```

    If there were multiple migrations run:

    ```bash
    rails db:rollback STEP=1
    ```

    This will:

    - Drop the `articles` table
    - Revert the database schema

2. Remove these files/directories if they exist:

    - `app/models/article.rb`
    - `app/controllers/articles_controller.rb`
    - `app/views/articles/`
    - `app/helpers/articles_helper.rb`
    - `app/assets/stylesheets/articles.scss` (or `.css`)
    - `test/models/article_test.rb` or `spec/models/article_spec.rb`
    - `test/controllers/articles_controller_test.rb` or specs

3. Edit `config/routes.rb` and delete:

    ```ruby
    resources :articles
    ```

4. If you want it fully gone:

    ```bash
    rm db/migrate/*create_articles*.rb
    ```

    Then reset the database if needed:

    ```bash
    rails db:reset
    ```

    ⚠️ **Warning**: `db:reset` drops and recreates the database — only do this in dev.


## `articles` Table Structure

Before creating the table, we define what it needs to store.

- `id` 
  - Serves as the primary key
  - Auto-generated by Rails 
  - Uniquely identifies each article 

- `title` 
  - Uses the `string` type
  - Limited in length (255 characters)

- `description` 
  - Uses the `text` type 
  - Supports longer content

Here's a sample table: 

| id  | title       | description            | user_id |
| --- | ----------- | ---------------------- | ------- |
| 1   | First post  | Introduction article   | 101     |
| 2   | Second post | Follow-up content      | 101     |
| 3   | Third post  | Another sample article | 203     |
| 4   | Fourth post | Deeper topic overview  | 145     |
| 5   | Fifth post  | Final example entry    | 203     |


## Creating the Table 

Tables are created through migration files. Migrations describe database changes and are applied in order. In the example below, a migration is generated to create the `articles` table.

```bash
rails generate migration create_articles
```

Rails creates a new migration file called `db/migrate/20230111005920_create_articles.rb`. The timestamp in the filename ensures migrations run in the correct order.

```ruby
class CreateArticles < ActiveRecord::Migration[6.1]
  def change
    create_table :articles do |t|
      t.timestamps
    end
  end
end
```

**Note:** When you use the `create_` prefix in the migration name, Rails assumes you are creating a table and auto-generates a `create_table` block, which includes the `t.timestamps`.

Modify the `articles` table and add a `title` column with a string type:

```ruby
class CreateArticles < ActiveRecord::Migration[6.1]
  def change
    create_table :articles do |t|
      t.timestamps
      t.string :title
    end
  end
end
```

Apply the migration to create the table.

```bash
rails db:migrate
```

Rails runs any migrations that have not been applied yet. After this completes, the `articles` table exists in the database. You can confirm this in `db/schema.rb`.

**Note:** I have another `application_records` in my schema because I have a another migration file in my `db` folder.

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_005920) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "articles", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.string "title"
  end
end
```

Once a migration has been run, Rails will not run it again because Rails tracks executed migrations. 

- Re-running `rails db:migrate` skips completed files
- Changes to old migrations are ignored

Editing a previously run migration will not update the database schema. This behavior prevents unexpected changes across environments. To update the table, you would need to do a rollback.


### Roll Back a Migration (for Local Testing)

The most recent migration can be undone using a rollback.

```bash
rails db:rollback
```

Output:

```bash
== 20230111005920 CreateArticles: reverting ===================================
-- drop_table(:articles)
   -> 0.0085s
== 20230111005920 CreateArticles: reverted (0.0210s) ==========================
```

This reverts the last migration and removes the `articles` table. If you check` db/schema`.rb, you’ll see that the `articles` table is no longer present.

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_005920) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
```

At this stage, you can modify the migration to add the required fields and run `rails db:migrate` again to recreate the table. This is fine for local testing, but it’s not recommended for shared projects. 

In those cases, the better approach is to create a new migration instead.


### Add New Changes using a New Migration

The correct way to update the database is to create a new migration.

First, generate a new migration.

```bash
rails generate migration add_desc_to_articles
```

This creates the `db/migrate/20230111012349_add_desc_to_articles.rb`. Since the migration name we used is generic, Rails didn't know what to add in the file.

```ruby
## db/migrate/20230111012349_add_desc_to_articles.rb
class AddDescToArticles < ActiveRecord::Migration[6.1]
  def change
  end
end
```

Update the migration file to add the `description` columns.

```ruby
## db/migrate/20230111012349_add_desc_to_articles.rb
class AddDescToArticles < ActiveRecord::Migration[6.1]
  def change
    add_column :articles, 
               :description,
               :text 
  end
end
```

Run the migration to apply the changes.

```bash
rails db:migrate
```

**Note:** Because we rolled back the migration earlier, the `articles` table had not been created yet. Running the migrate again now creates the table with both the `title` and `description` columns.

Checking the `db/schema.rb` again:

```ruby
ActiveRecord::Schema[6.1].define(version: 2023_01_11_014617) do
  create_table "application_records", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "articles", force: :cascade do |t|
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.text "description"
    t.string "title"
  end
end
```

With the database ready, the next step is to work with the Article `model` and connect it to the rest of the application.

## Create an `Article` Model

To work with the `articles` table, we need a model that connects the application logic to the database and handles data access.

Create the file `app/models/article.rb`. This file defines the `Article` model, and it inherits from `ApplicationRecord`, which is the base class for all models.

```ruby
## app/models/article.rb
class Article < ApplicationRecord
end
```

With this in place, Rails provides getters and setters for fields such as `title` and `description`, and it allows the application to communicate with the `articles` table.



## Using the Rails console

We can use the Rails console to directly interact with the database through models. It runs inside the application context and is commonly used for testing and debugging

From the project directory, run:

```bash
rails console
```

Once inside the console, you can test the connection to the `articles` table.

Calling `.all` fetches all rows:

```ruby
Article.all
```

Output:

```bash
Article Load (52.6ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='TestRailsApp'*/
=> [] 
```

Here, the `Article` class represents the `articles` table. If the result is an empty collection, it means the connection is working but there are no records yet.

There are three ways to create an article from the Rails console:

- Use `create`
- Use `new` followed by `save`
- Use `new` with attributes in one line


### 1. Using `create`

You can use the `create` method on the model class to add a record. This both builds the object and saves it to the database.

In the example below, `title` and `description` are column names from the `articles` table.

```ruby
Article.create(
  title: "First post",
  description: "Introduction article"
)
```

Output:

```bash
  TRANSACTION (1.6ms)  BEGIN immediate TRANSACTION /*application='TestRailsApp'*/
  Article Create (4.0ms)  INSERT INTO "articles" ("created_at", "title", "updated_at", "description") VALUES ('2026-01-11 02:17:34.505517', 'First post', '2026-01-11 02:17:34.505517', 'Introduction article') RETURNING "id" /*application='TestRailsApp'*/
  TRANSACTION (12.8ms)  COMMIT TRANSACTION /*application='TestRailsApp'*/
=>
#<Article:0x000076d895952e98
 id: 1,
 created_at: "2026-01-11 02:17:34.505517000 +0000",
 title: "First post",
 updated_at: "2026-01-11 02:17:34.505517000 +0000",
 description: "Introduction article">
```

Rails runs SQL statements behind the scenere to insert the row into the database and automatically fills in the ID and timestamps.

You can verify this by running `.all` again:

```ruby
$ Article.all

 Article Load (3.6ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='TestRailsApp'*/
=> 
[#<Article:0x000076d895addfd8
  id: 1,
  created_at: "2026-01-11 02:17:34.505517000 +0000",
  title: "First post",
  updated_at: "2026-01-11 02:17:34.505517000 +0000",
  description: "Introduction article">]
```

### 2. Using `new` and `save`

Another common approach is to create an object first and save it later.

- `new` creates an in-memory object
- `save` writes it to the database

Run the commands below: 

```ruby
article = Article.new
article.title = "Second post"
article.description = "Follow-up content"
article.save
```

Before calling `save`, the object exists only in memory. After saving, the ID and timestamps are filled in because the record now exists in the database.Che

Checking the rows again:

```ruby
$ Article.all

  Article Load (2.7ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='TestRailsApp'*/
=>
[#<Article:0x000076d89703d4a0
  id: 1,
  created_at: "2026-01-11 02:17:34.505517000 +0000",
  title: "First post",
  updated_at: "2026-01-11 02:17:34.505517000 +0000",
  description: "Introduction article">,
 #<Article:0x000076d89703d360
  id: 2,
  created_at: "2026-01-11 02:21:36.948319000 +0000",
  title: "Second post",
  updated_at: "2026-01-11 02:21:36.948319000 +0000",
  description: "Follow-up content">]
```

### 3. Use `new` with attributes in one line

You can also pass attributes directly when creating the object, then save it afterward.

```ruby
article = Article.new(
  title: "Third post",
  description: "Another sample article"
)
article.save
```

This produces the same result, but uses fewer steps.

To confirm the records were created:

```ruby
$ Article.all

  Article Load (2.5ms)  SELECT "articles".* FROM "articles" /* loading for pp */ LIMIT 11 /*application='TestRailsApp'*/
=> 
[#<Article:0x000076d89703f160
  id: 1,
  created_at: "2026-01-11 02:17:34.505517000 +0000",
  title: "First post",
  updated_at: "2026-01-11 02:17:34.505517000 +0000",
  description: "Introduction article">,
 #<Article:0x000076d89703f020
  id: 2,
  created_at: "2026-01-11 02:21:36.948319000 +0000",
  title: "Second post",
  updated_at: "2026-01-11 02:21:36.948319000 +0000",
  description: "Follow-up content">,
 #<Article:0x000076d89703eee0
  id: 3,
  created_at: "2026-01-11 02:26:38.002644000 +0000",
  title: "Third post",
  updated_at: "2026-01-11 02:26:38.002644000 +0000",
  description: "Another sample article">]
```

You should now see all articles that were saved. This confirms the model, database, and console are working together as expected.

### Exit the Rails console

To leave the console and return to the terminal:

```ruby
exit
```